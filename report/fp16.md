# Expose `AVX512 FP16` and `AVX` `F16C` ISA

## Background and motivation

This proposal allows to accelerate `FP16` operations through Intel's `FP16` ISAs. Both `F16c` and `AVX512 FP16` are covered. 

We use `System.Half` datatype --- the managed implementation of `FP16` in .NET --- as the foundational datatype for the `FP16` operations. Note that this proposal exposes the API for latter implementation, but it will require some .NET internal rework, particularly around the use of `System.Half` as a hardware accelerated vectorized data type. 

## API Proposal

```csharp

class F16c : Avx2
{
  // vcvtph2ps
  public static Vector128<float> ConvertToSingle(Vector128<Half> value);
  public static Vector258<float> ConvertToSingle(Vector258<Half> value);

  // vcvtps2ph
  public static Vector128<Half> ConvertToVector128Half(Vector128<float> value, byte control);
  public static Vector258<Half> ConvertToVector256Half(Vector258<float> value, byte control);
}

class Avx512Fp16 : Avx512F 
{
  // vaddph
  public static Vector512<Half> Add(Vector512<Half> left, Vector512<Half> right);
  
  // vdivph
  public static Vector512<Half> Divide(Vector512<Half> left, Vector512<Half> right);

  // vgetexpph
  public static Vector512<Half> GetExponent(Vector512<Half> value);

  // vgetmantph
  public static Vector512<Half> GetMantissa(Vector512<Half> value, byte control);

  // vmaxph
  public static Vector512<Half> Max(Vector512<Half> left, Vector512<Half> right);

  // vminph
  public static Vector512<Half> Min(Vector512<Half> value, Vector512<Half> right);

  // vminph
  public static Vector512<Half> Multiply(Vector512<Half> left, Vector512<Half> right);

  // vrcpph
  public static Vector512<Half> Reciprocal(Vector512<Half> left);

  // vreduceph
  public static Half Reduce(Vector512<Half> left, byte control);

  // vrndscaleph
  public static Vector512<Half> RoundScale(Vector512<Half> left, byte control);

  // vrsqrtph
  public static Vector512<Half> ReciprocalSqrt(Vector512<Half> left);

  // vscalefph
  public static Vector512<Half> FloatingPointScale(Vector512<Half> left, Vector512<Half> right, byte control);

  // vsqrtph
  public static Vector512<Half> Sqrt(Vector512<Half> left);

  // vsubph
  public static Vector512<Half> Subtract(Vector512<Half> left, Vector512<Half> right);

  // vfmaddpch
  public static Vector512<Half> FusedComplexMultiplyAdd(Vector512<Half> left, Vector512<Half> right);

  // vfcaddlpch
  public static Vector512<Half> FusedComplexMultiplyAddConjugate(Vector512<Half> left, Vector512<Half> right);

  // vfmulpch
  public static Vector512<Half> ComplexMultiply(Vector512<Half> left, Vector512<Half> right);

  // vfcmulpch
  public static Vector512<Half> ComplexMultiplyConjugate(Vector512<Half> left, Vector512<Half> right);

  // vfmaddsubXXXph
  public static Vector512<Half> FusedMultiplyAddSubtract(Vector512<Half> a, Vector512<Half> b, Vector512<Half> c);

  // vfmsubaddXXXph
  public static Vector512<Half> FusedMultiplySubtractAdd(Vector512<Half> a, Vector512<Half> b, Vector512<Half> c);

  // vfmaddXXXph
  public static Vector512<Half> FusedMultiplyAdd(Vector512<Half> a, Vector512<Half> b, Vector512<Half> c);

  // vfmsubXXXph
  public static Vector512<Half> FusedMultiplySubtract(Vector512<Half> a, Vector512<Half> b, Vector512<Half> c);

  // vfnmaddXXXph
  public static Vector512<Half> FusedMultiplyAddNegated(Vector512<Half> a, Vector512<Half> b, Vector512<Half> c);

  // vfnmsubXXXph
  public static Vector512<Half> FusedMultiplySubtractNegated(Vector512<Half> a, Vector512<Half> b, Vector512<Half> c);

  // vcmpph
  public static Vector512<Half> Compare(Vector512<Half> left, Vector512<Half> right, FloatComparisonMode mode);
  public static Vector512<Half> CompareGreaterThan(Vector512<Half> left, Vector512<Half> right);
  public static Vector512<Half> CompareGreaterThanOrEqual(Vector512<Half> left, Vector512<Half> right);
  public static Vector512<Half> CompareLessThan(Vector512<Half> left, Vector512<Half> right);
  public static Vector512<Half> CompareLessThanOrEqual(Vector512<Half> left, Vector512<Half> right);
  public static Vector512<Half> CompareNotEqual(Vector512<Half> left, Vector512<Half> right);
  public static Vector512<Half> CompareNotGreaterThan(Vector512<Half> left, Vector512<Half> right);
  public static Vector512<Half> CompareNotGreaterThanOrEqual(Vector512<Half> left, Vector512<Half> right);
  public static Vector512<Half> CompareNotLessThan(Vector512<Half> left, Vector512<Half> right);
  public static Vector512<Half> CompareNotLessThanOrEqual(Vector512<Half> left, Vector512<Half> right);
  public static Vector512<Half> CompareOrdered(Vector512<Half> left, Vector512<Half> right);
  public static Vector512<Half> CompareUnordered(Vector512<Half> left, Vector512<Half> right);

  // vcvtw2ph
  public static Vector512<Half> ConvertToVector512Half(Vector512<short> left);

  // vcvtdq2ph
  public static Vector512<Half> ConvertToVector512Half(Vector512<int> left);

  // vcvtqq2ph
  public static Vector512<Half> ConvertToVector512Half(Vector512<long> left);

  // vcvtuw2ph
  public static Vector512<Half> ConvertToVector512Half(Vector512<ushort> left);

  // vcvtudq2ph
  public static Vector512<Half> ConvertToVector512Half(Vector512<uint> left);

  // vcvtuqq2ph
  public static Vector512<Half> ConvertToVector512Half(Vector512<ulong> left);

  // vcvtps2ph
  public static Vector512<Half> ConvertToVector512Half(Vector512<float> left);

  // vcvtpd2ph
  public static Vector512<Half> ConvertToVector512Half(Vector512<double> left);

  // vcvtph2w
  public static Vector512<short> ConvertToVectorInt16(Vector512<Half> left);

  // vcvtph2dq
  public static Vector512<int> ConvertToVectorInt32(Vector512<Half> left);

  // vcvtph2qq
  public static Vector512<long> ConvertToVectorInt64(Vector512<Half> left);
  
  // vcvtph2uw
  public static Vector512<ushort> ConvertToVectorUInt16(Vector512<Half> left);

  // vcvtph2udq
  public static Vector512<uint> ConvertToVectorUInt32(Vector512<Half> left);

  // vcvtph2uqq
  public static Vector512<ulong> ConvertToVectorUInt64(Vector512<Half> left);

  // vcvtph2ps
  public static Vector512<float> ConvertToVectorSingle(Vector512<Half> left);

  // vcvtph2pd
  public static Vector512<double> ConvertToVectorDouble(Vector512<Half> left);

  // SCALAR Ops

  // vaddph
  public static Vector128<Half> AddScalar(Vector128<Half> left, Vector128<Half> right);
  
  // vdivph
  public static Vector128<Half> DivideScalar(Vector128<Half> left, Vector128<Half> right);

  // vgetexpph
  public static Vector128<Half> GetExponentScalar(Vector128<Half> value);

  // vgetmantph
  public static Vector128<Half> GetMantissaScalar(Vector128<Half> value, byte control);

  // vmaxph
  public static Vector128<Half> MaxScalar(Vector128<Half> left, Vector128<Half> right);

  // vminph
  public static Vector128<Half> MinScalar(Vector128<Half> value, Vector128<Half> right);

  // vminph
  public static Vector128<Half> MultiplyScalar(Vector128<Half> left, Vector128<Half> right);

  // vrcpph
  public static Vector128<Half> ReciprocalScalar(Vector128<Half> left);

  // vreduceph
  public static Half ReduceScalar(Vector128<Half> left, byte control);

  // vrndscaleph
  public static Vector128<Half> RoundScaleScalar(Vector128<Half> left, byte control);

  // vrsqrtph
  public static Vector128<Half> ReciprocalSqrtScalar(Vector128<Half> left);

  // vscalefph
  public static Vector128<Half> FloatingPointScaleScalar(Vector128<Half> left, Vector128<Half> right, byte control);

  // vsqrtph
  public static Vector128<Half> SqrtScalar(Vector128<Half> left);

  // vsubph
  public static Vector128<Half> SubtractScalar(Vector128<Half> left, Vector128<Half> right);

  // vfmaddpch
  public static Vector128<Half> FusedComplexMultiplyAddScalar(Vector128<Half> left, Vector128<Half> right);

  // vfcaddlpch
  public static Vector128<Half> FusedComplexMultiplyAddConjugateScalar(Vector128<Half> left, Vector128<Half> right);

  // vfmulpch
  public static Vector128<Half> ComplexMultiplyScalar(Vector128<Half> left, Vector128<Half> right);

  // vfcmulpch
  public static Vector128<Half> ComplexMultiplyConjugateScalar(Vector128<Half> left, Vector128<Half> right);

  // vfmaddsubXXXph
  public static Vector128<Half> FusedMultiplyAddSubtractScalar(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

  // vfmsubaddXXXph
  public static Vector128<Half> FusedMultiplySubtractAddScalar(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

  // vfmaddXXXph
  public static Vector128<Half> FusedMultiplyAddScalar(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

  // vfmsubXXXph
  public static Vector128<Half> FusedMultiplySubtractScalar(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

  // vfnmaddXXXph
  public static Vector128<Half> FusedMultiplyAddNegatedScalar(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

  // vfnmsubXXXph
  public static Vector128<Half> FusedMultiplySubtractNegatedScalar(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

  public static Vector128<Half> CompareScalar(Vector128<Half> left, Vector128<Half> right, FloatComparisonMode mode);
  public static Vector128<Half> CompareGreaterThanScalar(Vector128<Half> left, Vector128<Half> right);
  public static Vector128<Half> CompareGreaterThanOrEqualScalar(Vector128<Half> left, Vector128<Half> right);
  public static Vector128<Half> CompareLessThanScalar(Vector128<Half> left, Vector128<Half> right);
  public static Vector128<Half> CompareLessThanOrEqualScalar(Vector128<Half> left, Vector128<Half> right);
  public static Vector128<Half> CompareNotEqualScalar(Vector128<Half> left, Vector128<Half> right);
  public static Vector128<Half> CompareNotGreaterThanScalar(Vector128<Half> left, Vector128<Half> right);
  public static Vector128<Half> CompareNotGreaterThanOrEqualScalar(Vector128<Half> left, Vector128<Half> right);
  public static Vector128<Half> CompareNotLessThanScalar(Vector128<Half> left, Vector128<Half> right);
  public static Vector128<Half> CompareNotLessThanOrEqualScalar(Vector128<Half> left, Vector128<Half> right);
  public static Vector128<Half> CompareOrderedScalar(Vector128<Half> left, Vector128<Half> right);
  public static Vector128<Half> CompareUnorderedScalar(Vector128<Half> left, Vector128<Half> right);

  // vcvtsi2sh
  public static Vector128<Half> ConvertToHalfScalar(int left);
  public static Vector128<Half> ConvertToHalfScalar(long left);

  // vcvtusi2sh
  public static Vector128<Half> ConvertToHalfScalar(uint left);
  public static Vector128<Half> ConvertToHalfScalar(ulong left);

  // vcvtss2sh
  public static Vector128<Half> ConvertToHalfScalar(Vector128<float> left);

  // vcvtsd2sh
  public static Vector128<Half> ConvertToHalfScalar(Vector128<double> left);

  // vcvtsh2si
  public static int ConvertToInt32Scalar(Vector128<Half> left);
  public static long ConvertToInt64Scalar(Vector128<Half> left);

  // vcvtsh2usi
  public static uint ConvertToUInt32Scalar(Vector128<Half> left);
  public static ulong ConvertToUInt64Scalar(Vector128<Half> left);

  // vcvtsh2ss
  public static Vector128<float> ConvertToFloatScalar(Vector128<Half> left);

  // vcvtsh2sd
  public static Vector128<double> ConvertToDoubleScalar(Vector128<Half> left);

  
  class VL : Avx512F.VL
  {
    // vaddph
    public static Vector128<Half> Add(Vector128<Half> left, Vector128<Half> right);
    
    // vdivph
    public static Vector128<Half> Divide(Vector128<Half> left, Vector128<Half> right);

    // vgetexpph
    public static Vector128<Half> GetExponent(Vector128<Half> value);

    // vgetmantph
    public static Vector128<Half> GetMantissa(Vector128<Half> value, byte control);

    // vmaxph
    public static Vector128<Half> Max(Vector128<Half> left, Vector128<Half> right);

    // vminph
    public static Vector128<Half> Min(Vector128<Half> value, Vector128<Half> right);

    // vminph
    public static Vector128<Half> Multiply(Vector128<Half> left, Vector128<Half> right);

    // vrcpph
    public static Vector128<Half> Reciprocal(Vector128<Half> left);

    // vreduceph
    public static Half Reduce(Vector128<Half> left, byte control);

    // vrndscaleph
    public static Vector128<Half> RoundScale(Vector128<Half> left, byte control);

    // vrsqrtph
    public static Vector128<Half> ReciprocalSqrt(Vector128<Half> left);

    // vscalefph
    public static Vector128<Half> FloatingPointScale(Vector128<Half> left, Vector128<Half> right, byte control);

    // vsqrtph
    public static Vector128<Half> Sqrt(Vector128<Half> left);

    // vsubph
    public static Vector128<Half> Subtract(Vector128<Half> left, Vector128<Half> right);

    // vfmaddpch
    public static Vector128<Half> FusedComplexMultiplyAdd(Vector128<Half> left, Vector128<Half> right);

    // vfcaddlpch
    public static Vector128<Half> FusedComplexMultiplyAddConjugate(Vector128<Half> left, Vector128<Half> right);

    // vfmulpch
    public static Vector128<Half> ComplexMultiply(Vector128<Half> left, Vector128<Half> right);

    // vfcmulpch
    public static Vector128<Half> ComplexMultiplyConjugate(Vector128<Half> left, Vector128<Half> right);

    // vfmaddsubXXXph
    public static Vector128<Half> FusedMultiplyAddSubtract(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

    // vfmsubaddXXXph
    public static Vector128<Half> FusedMultiplySubtractAdd(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

    // vfmaddXXXph
    public static Vector128<Half> FusedMultiplyAdd(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

    // vfmsubXXXph
    public static Vector128<Half> FusedMultiplySubtract(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

    // vfnmaddXXXph
    public static Vector128<Half> FusedMultiplyAddNegated(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

    // vfnmsubXXXph
    public static Vector128<Half> FusedMultiplySubtractNegated(Vector128<Half> a, Vector128<Half> b, Vector128<Half> c);

    // vcmpph
    public static Vector128<Half> Compare(Vector128<Half> left, Vector128<Half> right, FloatComparisonMode mode);
    public static Vector128<Half> CompareGreaterThan(Vector128<Half> left, Vector128<Half> right);
    public static Vector128<Half> CompareGreaterThanOrEqual(Vector128<Half> left, Vector128<Half> right);
    public static Vector128<Half> CompareLessThan(Vector128<Half> left, Vector128<Half> right);
    public static Vector128<Half> CompareLessThanOrEqual(Vector128<Half> left, Vector128<Half> right);
    public static Vector128<Half> CompareNotEqual(Vector128<Half> left, Vector128<Half> right);
    public static Vector128<Half> CompareNotGreaterThan(Vector128<Half> left, Vector128<Half> right);
    public static Vector128<Half> CompareNotGreaterThanOrEqual(Vector128<Half> left, Vector128<Half> right);
    public static Vector128<Half> CompareNotLessThan(Vector128<Half> left, Vector128<Half> right);
    public static Vector128<Half> CompareNotLessThanOrEqual(Vector128<Half> left, Vector128<Half> right);
    public static Vector128<Half> CompareOrdered(Vector128<Half> left, Vector128<Half> right);
    public static Vector128<Half> CompareUnordered(Vector128<Half> left, Vector128<Half> right);

    // vcvtw2ph
    public static Vector128<Half> ConvertToVector128Half(Vector128<short> left);

    // vcvtdq2ph
    public static Vector128<Half> ConvertToVector128Half(Vector128<int> left);

    // vcvtqq2ph
    public static Vector128<Half> ConvertToVector128Half(Vector128<long> left);

    // vcvtuw2ph
    public static Vector128<Half> ConvertToVector128Half(Vector128<ushort> left);

    // vcvtudq2ph
    public static Vector128<Half> ConvertToVector128Half(Vector128<uint> left);

    // vcvtuqq2ph
    public static Vector128<Half> ConvertToVector128Half(Vector128<ulong> left);

    // vcvtps2ph
    public static Vector128<Half> ConvertToVector128Half(Vector128<float> left);

    // vcvtpd2ph
    public static Vector128<Half> ConvertToVector128Half(Vector128<double> left);

    // vcvtph2w
    public static Vector128<short> ConvertToVectorInt16(Vector128<Half> left);

    // vcvtph2dq
    public static Vector128<int> ConvertToVectorInt32(Vector128<Half> left);

    // vcvtph2qq
    public static Vector128<long> ConvertToVectorInt64(Vector128<Half> left);
    
    // vcvtph2uw
    public static Vector128<ushort> ConvertToVectorUInt16(Vector128<Half> left);

    // vcvtph2udq
    public static Vector128<uint> ConvertToVectorUInt32(Vector128<Half> left);

    // vcvtph2uqq
    public static Vector128<ulong> ConvertToVectorUInt64(Vector128<Half> left);

    // vcvtph2ps
    public static Vector128<float> ConvertToVectorSingle(Vector128<Half> left);

    // vcvtph2pd
    public static Vector128<double> ConvertToVectorDouble(Vector128<Half> left);

    // 256
    // vaddph
    public static Vector256<Half> Add(Vector256<Half> left, Vector256<Half> right);
    
    // vdivph
    public static Vector256<Half> Divide(Vector256<Half> left, Vector256<Half> right);

    // vgetexpph
    public static Vector256<Half> GetExponent(Vector256<Half> value);

    // vgetmantph
    public static Vector256<Half> GetMantissa(Vector256<Half> value, byte control);

    // vmaxph
    public static Vector256<Half> Max(Vector256<Half> left, Vector256<Half> right);

    // vminph
    public static Vector256<Half> Min(Vector256<Half> value, Vector256<Half> right);

    // vminph
    public static Vector256<Half> Multiply(Vector256<Half> left, Vector256<Half> right);

    // vrcpph
    public static Vector256<Half> Reciprocal(Vector256<Half> left);

    // vreduceph
    public static Half Reduce(Vector256<Half> left, byte control);

    // vrndscaleph
    public static Vector256<Half> RoundScale(Vector256<Half> left, byte control);

    // vrsqrtph
    public static Vector256<Half> ReciprocalSqrt(Vector256<Half> left);

    // vscalefph
    public static Vector256<Half> FloatingPointScale(Vector256<Half> left, Vector256<Half> right, byte control);

    // vsqrtph
    public static Vector256<Half> Sqrt(Vector256<Half> left);

    // vsubph
    public static Vector256<Half> Subtract(Vector256<Half> left, Vector256<Half> right);

    // vfmaddpch
    public static Vector256<Half> FusedComplexMultiplyAdd(Vector256<Half> left, Vector256<Half> right);

    // vfcaddlpch
    public static Vector256<Half> FusedComplexMultiplyAddConjugate(Vector256<Half> left, Vector256<Half> right);

    // vfmulpch
    public static Vector256<Half> ComplexMultiply(Vector256<Half> left, Vector256<Half> right);

    // vfcmulpch
    public static Vector256<Half> ComplexMultiplyConjugate(Vector256<Half> left, Vector256<Half> right);

    // vfmaddsubXXXph
    public static Vector256<Half> FusedMultiplyAddSubtract(Vector256<Half> a, Vector256<Half> b, Vector256<Half> c);

    // vfmsubaddXXXph
    public static Vector256<Half> FusedMultiplySubtractAdd(Vector256<Half> a, Vector256<Half> b, Vector256<Half> c);

    // vfmaddXXXph
    public static Vector256<Half> FusedMultiplyAdd(Vector256<Half> a, Vector256<Half> b, Vector256<Half> c);

    // vfmsubXXXph
    public static Vector256<Half> FusedMultiplySubtract(Vector256<Half> a, Vector256<Half> b, Vector256<Half> c);

    // vfnmaddXXXph
    public static Vector256<Half> FusedMultiplyAddNegated(Vector256<Half> a, Vector256<Half> b, Vector256<Half> c);

    // vfnmsubXXXph
    public static Vector256<Half> FusedMultiplySubtractNegated(Vector256<Half> a, Vector256<Half> b, Vector256<Half> c);

    // vcmpph
    public static Vector256<Half> Compare(Vector256<Half> left, Vector256<Half> right, FloatComparisonMode mode);
    public static Vector256<Half> CompareGreaterThan(Vector256<Half> left, Vector256<Half> right);
    public static Vector256<Half> CompareGreaterThanOrEqual(Vector256<Half> left, Vector256<Half> right);
    public static Vector256<Half> CompareLessThan(Vector256<Half> left, Vector256<Half> right);
    public static Vector256<Half> CompareLessThanOrEqual(Vector256<Half> left, Vector256<Half> right);
    public static Vector256<Half> CompareNotEqual(Vector256<Half> left, Vector256<Half> right);
    public static Vector256<Half> CompareNotGreaterThan(Vector256<Half> left, Vector256<Half> right);
    public static Vector256<Half> CompareNotGreaterThanOrEqual(Vector256<Half> left, Vector256<Half> right);
    public static Vector256<Half> CompareNotLessThan(Vector256<Half> left, Vector256<Half> right);
    public static Vector256<Half> CompareNotLessThanOrEqual(Vector256<Half> left, Vector256<Half> right);
    public static Vector256<Half> CompareOrdered(Vector256<Half> left, Vector256<Half> right);
    public static Vector256<Half> CompareUnordered(Vector256<Half> left, Vector256<Half> right);

    // vcvtw2ph
    public static Vector256<Half> ConvertToVector256Half(Vector256<short> left);

    // vcvtdq2ph
    public static Vector256<Half> ConvertToVector256Half(Vector256<int> left);

    // vcvtqq2ph
    public static Vector256<Half> ConvertToVector256Half(Vector256<long> left);

    // vcvtuw2ph
    public static Vector256<Half> ConvertToVector256Half(Vector256<ushort> left);

    // vcvtudq2ph
    public static Vector256<Half> ConvertToVector256Half(Vector256<uint> left);

    // vcvtuqq2ph
    public static Vector256<Half> ConvertToVector256Half(Vector256<ulong> left);

    // vcvtps2ph
    public static Vector256<Half> ConvertToVector256Half(Vector256<float> left);

    // vcvtpd2ph
    public static Vector256<Half> ConvertToVector256Half(Vector256<double> left);

    // vcvtph2w
    public static Vector256<short> ConvertToVectorInt16(Vector256<Half> left);

    // vcvtph2dq
    public static Vector256<int> ConvertToVectorInt32(Vector256<Half> left);

    // vcvtph2qq
    public static Vector256<long> ConvertToVectorInt64(Vector256<Half> left);
    
    // vcvtph2uw
    public static Vector256<ushort> ConvertToVectorUInt16(Vector256<Half> left);

    // vcvtph2udq
    public static Vector256<uint> ConvertToVectorUInt32(Vector256<Half> left);

    // vcvtph2uqq
    public static Vector256<ulong> ConvertToVectorUInt64(Vector256<Half> left);

    // vcvtph2ps
    public static Vector256<float> ConvertToVectorSingle(Vector256<Half> left);

    // vcvtph2pd
    public static Vector256<double> ConvertToVectorDouble(Vector256<Half> left);
  }
  
}

```

## API Usage

N/A

## Alternative Designs

N/A

## Risks

N/A